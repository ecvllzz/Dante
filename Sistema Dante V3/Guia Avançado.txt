Guia Avan√ßado de An√°lise e Otimiza√ß√£o: FFmpeg.wasm Video-to-Audio Converterüìã SE√á√ÉO 1: AN√ÅLISE DE ESCOPO E OBJETIVOSProp√≥sito do C√≥digo```OBJETIVO PRIM√ÅRIO: Converter arquivos de v√≠deo para MP3 no navegador usando FFmpeg.wasmCONTEXTO: Aplica√ß√£o web em TypeScript que processa m√≠dia client-sideUSU√ÅRIO FINAL: Falante de portugu√™s brasileiro```Componentes IdentificadosGerenciamento de Inst√¢ncia FFmpeg (singleton pattern)Carregamento Ass√≠ncrono do core FFmpegPipeline de Convers√£o (write ‚Üí exec ‚Üí read ‚Üí cleanup)Rastreamento de Progresso via callbacksTratamento de Erros b√°sico---üö® SE√á√ÉO 2: ERROS CR√çTICOS IDENTIFICADOSERRO CR√çTICO #1: Race Condition em Convers√µes Concorrentes```typescript// PROBLEMA:const inputFileName = 'input.video';  // ‚Üê Nome fixoconst outputFileName = 'output.mp3';   // ‚Üê Nome fixo// CEN√ÅRIO DE FALHA:// Usu√°rio seleciona 2 v√≠deos simultaneamente// Convers√£o A: writeFile('input.video', videoA)// Convers√£o B: writeFile('input.video', videoB) ‚Üê Sobrescreve A// Convers√£o A: exec() ‚Üê Processa arquivo errado```SEVERIDADE: ‚ö†Ô∏è CR√çTICA - Corrup√ß√£o de dados garantida em uso realIMPACTO:Convers√µes falham silenciosamenteUsu√°rio recebe arquivo incorretoImposs√≠vel processar m√∫ltiplos arquivos---ERRO CR√çTICO #2: Falta de Valida√ß√£o de Entrada```typescript// PROBLEMA: Aceita qualquer File sem verifica√ß√£oexport const convertToAudio = async (videoFile: File, ...) => {    // ‚Üê Sem verifica√ß√£o de tipo MIME    // ‚Üê Sem limite de tamanho    // ‚Üê Sem valida√ß√£o de formato}// CEN√ÅRIO DE FALHA:// Usu√°rio envia arquivo de 5GB ‚Üí Browser trava/crash// Usu√°rio envia .exe renomeado ‚Üí FFmpeg falha```SEVERIDADE: üî¥ ALTA - Experi√™ncia do usu√°rio comprometida---ERRO CR√çTICO #3: Vazamento de Mem√≥ria em Listeners```typescript// PROBLEMA: Listener pode n√£o ser removido em casos de erroffmpeg.on('progress', progressListener);try {    await ffmpeg.exec(...);} finally {    ffmpeg.off('progress', progressListener); // ‚Üê Pode n√£o executar se erro antes}```SEVERIDADE: üü° M√âDIA - Degrada√ß√£o de performance ao longo do tempo---ERRO CR√çTICO #4: Cleanup Incompleto em Erros```typescriptfinally {    // Se writeFile falhou, deleteFile lan√ßa exce√ß√£o    await ffmpeg.deleteFile(inputFileName);  // ‚Üê Pode falhar    await ffmpeg.deleteFile(outputFileName); // ‚Üê Pode falhar    ffmpeg.off('progress', progressListener);}```SEVERIDADE: üü° M√âDIA - Polui√ß√£o do sistema de arquivos virtual---üîß SE√á√ÉO 3: M√âTODOS DE RESOLU√á√ÉO AVAN√áADOSRESOLU√á√ÉO #1: Sistema de Convers√£o Thread-Safe```typescript/** * INSTRU√á√ÉO PARA LLM: * Implemente um sistema de filas que serializa convers√µes. * Use Promise chaining para garantir execu√ß√£o sequencial. */class ConversionQueue {    private queue: Promise<void> = Promise.resolve();    enqueue<T>(task: () => Promise<T>): Promise<T> {        return new Promise((resolve, reject) => {            this.queue = this.queue                .then(() => task())                .then(resolve)                .catch(reject);        });    }}const conversionQueue = new ConversionQueue();export const convertToAudio = async (    videoFile: File,     onProgress?: (progress: number) => void): Promise<File> => {    return conversionQueue.enqueue(() =>         performConversion(videoFile, onProgress)    );};```ALTERNATIVA: Nomes de Arquivo √önicos```typescript/** * INSTRU√á√ÉO PARA LLM: * Gere nomes √∫nicos usando timestamp + random + contador. * Garanta unicidade mesmo em execu√ß√µes simult√¢neas. */let fileCounter = 0;const generateUniqueFilename = (extension: string): string => {    const timestamp = Date.now();    const random = Math.random().toString(36).substring(2, 9);    const counter = ++fileCounter;    return `${timestamp}_${random}_${counter}.${extension}`;};// Uso:const inputFileName = generateUniqueFilename('video');const outputFileName = generateUniqueFilename('mp3');```---RESOLU√á√ÉO #2: Sistema de Valida√ß√£o Robusto```typescript/** * INSTRU√á√ÉO PARA LLM: * Implemente valida√ß√µes em camadas antes de processar. * Forne√ßa mensagens de erro em portugu√™s para o usu√°rio. */interface ValidationResult {    isValid: boolean;    error?: string;}const VALID_VIDEO_TYPES = [    'video/mp4',    'video/webm',    'video/ogg',    'video/quicktime',    'video/x-msvideo',    'video/x-matroska'];const MAX_FILE_SIZE = 500 * 1024 * 1024; // 500MBconst validateVideoFile = (file: File): ValidationResult => {    // Valida√ß√£o 1: Tipo MIME    if (!VALID_VIDEO_TYPES.includes(file.type)) {        return {            isValid: false,            error: `Formato n√£o suportado. Tipos aceitos: ${VALID_VIDEO_TYPES.join(', ')}`        };    }    // Valida√ß√£o 2: Tamanho    if (file.size > MAX_FILE_SIZE) {        const maxSizeMB = MAX_FILE_SIZE / (1024 * 1024);        return {            isValid: false,            error: `Arquivo muito grande. Tamanho m√°ximo: ${maxSizeMB}MB`        };    }    // Valida√ß√£o 3: Nome de arquivo    if (!file.name || file.name.length === 0) {        return {            isValid: false,            error: 'Nome de arquivo inv√°lido'        };    }    // Valida√ß√£o 4: Extens√£o (verifica√ß√£o adicional)    const validExtensions = ['.mp4', '.webm', '.ogg', '.mov', '.avi', '.mkv'];    const hasValidExtension = validExtensions.some(ext =>         file.name.toLowerCase().endsWith(ext)    );    if (!hasValidExtension) {        return {            isValid: false,            error: `Extens√£o de arquivo n√£o reconhecida. Use: ${validExtensions.join(', ')}`        };    }    return { isValid: true };};// Integra√ß√£o na fun√ß√£o principal:export const convertToAudio = async (    videoFile: File,     onProgress?: (progress: number) => void): Promise<File> => {    const validation = validateVideoFile(videoFile);    if (!validation.isValid) {        throw new Error(validation.error);    }    // ... resto do c√≥digo};```---RESOLU√á√ÉO #3: Gerenciamento Avan√ßado de Recursos```typescript/** * INSTRU√á√ÉO PARA LLM: * Implemente cleanup defensivo que n√£o falha. * Use Promise.allSettled para garantir todas as opera√ß√µes de limpeza. */const safeCleanup = async (    ffmpeg: FFmpeg,     files: string[],     listener?: ProgressCallback): Promise<void> => {    // Remove listener primeiro (opera√ß√£o s√≠ncrona)    if (listener) {        try {            ffmpeg.off('progress', listener);        } catch (error) {            console.warn('Falha ao remover listener:', error);        }    }    // Remove arquivos de forma segura    const deletePromises = files.map(async (filename) => {        try {            await ffmpeg.deleteFile(filename);        } catch (error) {            console.warn(`Falha ao deletar ${filename}:`, error);            // N√£o propaga o erro - cleanup √© best-effort        }    });    await Promise.allSettled(deletePromises);};// Uso na fun√ß√£o principal:try {    await ffmpeg.writeFile(inputFileName, await fetchFile(videoFile));    await ffmpeg.exec([...]);    const data = await ffmpeg.readFile(outputFileName);    // ... cria√ß√£o do File    return audioFile;} finally {    await safeCleanup(ffmpeg, [inputFileName, outputFileName], progressListener);}```---RESOLU√á√ÉO #4: Sistema de Tratamento de Erros Contextual```typescript/** * INSTRU√á√ÉO PARA LLM: * Crie uma hierarquia de erros espec√≠ficos do dom√≠nio. * Forne√ßa mensagens de erro acion√°veis em portugu√™s. */class ConversionError extends Error {    constructor(        message: string,        public readonly code: string,        public readonly userMessage: string    ) {        super(message);        this.name = 'ConversionError';    }}const ERROR_MESSAGES = {    FFMPEG_LOAD_FAILED: {        technical: 'Failed to load FFmpeg core',        user: 'N√£o foi poss√≠vel carregar o motor de convers√£o. Verifique sua conex√£o com a internet e tente novamente.'    },    FILE_WRITE_FAILED: {        technical: 'Failed to write file to virtual filesystem',        user: 'Erro ao preparar o arquivo para convers√£o. O arquivo pode estar corrompido.'    },    CONVERSION_FAILED: {        technical: 'FFmpeg exec failed',        user: 'Falha durante a convers√£o. O arquivo de v√≠deo pode estar danificado ou em um formato n√£o suportado.'    },    FILE_READ_FAILED: {        technical: 'Failed to read output file',        user: 'Erro ao gerar o arquivo de √°udio. Tente novamente.'    }};const wrapError = (error: unknown, code: keyof typeof ERROR_MESSAGES): ConversionError => {    const messages = ERROR_MESSAGES[code];    const originalMessage = error instanceof Error ? error.message : String(error);    return new ConversionError(        `${messages.technical}: ${originalMessage}`,        code,        messages.user    );};// Uso:try {    await ffmpeg.writeFile(inputFileName, await fetchFile(videoFile));} catch (error) {    throw wrapError(error, 'FILE_WRITE_FAILED');}```---üìö SE√á√ÉO 4: MELHORES PR√ÅTICAS DE IMPLEMENTA√á√ÉOPR√ÅTICA #1: Configura√ß√£o Otimizada do FFmpeg```typescript/** * INSTRU√á√ÉO PARA LLM: * Configure FFmpeg com par√¢metros otimizados para diferentes casos de uso. */interface ConversionOptions {    quality: 'baixa' | 'm√©dia' | 'alta' | 'm√°xima';    bitrate?: string;    sampleRate?: number;}const QUALITY_PRESETS = {    baixa: ['-q:a', '9', '-ar', '22050'],      // ~64kbps    m√©dia: ['-q:a', '5', '-ar', '44100'],      // ~128kbps    alta: ['-q:a', '2', '-ar', '44100'],       // ~192kbps    m√°xima: ['-b:a', '320k', '-ar', '48000']   // 320kbps CBR};const buildFFmpegArgs = (    inputFile: string,    outputFile: string,    options: ConversionOptions): string[] => {    const baseArgs = ['-i', inputFile, '-vn', '-acodec', 'libmp3lame'];    const qualityArgs = QUALITY_PRESETS[options.quality];    return [...baseArgs, ...qualityArgs, outputFile];};```---PR√ÅTICA #2: Monitoramento de Performance```typescript/** * INSTRU√á√ÉO PARA LLM: * Adicione telemetria para monitorar performance e identificar gargalos. */interface ConversionMetrics {    fileSize: number;    duration: number;    throughput: number; // MB/s    success: boolean;}const measureConversion = async <T>(    task: () => Promise<T>,    fileSize: number): Promise<{ result: T; metrics: ConversionMetrics }> => {    const startTime = performance.now();    let success = false;    try {        const result = await task();        success = true;        return { result, metrics: calculateMetrics() };    } catch (error) {        throw error;    } finally {        const duration = performance.now() - startTime;        if (success) {            console.log('[Metrics]', {                fileSize: `${(fileSize / 1024 / 1024).toFixed(2)} MB`,                duration: `${(duration / 1000).toFixed(2)}s`,                throughput: `${(fileSize / 1024 / 1024 / (duration / 1000)).toFixed(2)} MB/s`            });        }    }    function calculateMetrics(): ConversionMetrics {        const duration = performance.now() - startTime;        return {            fileSize,            duration,            throughput: fileSize / (duration / 1000),            success        };    }};```---PR√ÅTICA #3: Sistema de Cache de Inst√¢ncia FFmpeg```typescript/** * INSTRU√á√ÉO PARA LLM: * Implemente caching inteligente com invalida√ß√£o autom√°tica. */class FFmpegManager {    private instance: FFmpeg | null = null;    private isLoading = false;    private loadPromise: Promise<FFmpeg> | null = null;    private lastUsed: number = Date.now();    private readonly IDLE_TIMEOUT = 5 * 60 * 1000; // 5 minutos    async getInstance(): Promise<FFmpeg> {        this.lastUsed = Date.now();        // Se j√° carregado, retorna        if (this.instance) {            return this.instance;        }        // Se est√° carregando, aguarda        if (this.isLoading && this.loadPromise) {            return this.loadPromise;        }        // Inicia carregamento        this.isLoading = true;        this.loadPromise = this.loadFFmpeg();        try {            this.instance = await this.loadPromise;            this.scheduleCleanup();            return this.instance;        } finally {            this.isLoading = false;            this.loadPromise = null;        }    }    private async loadFFmpeg(): Promise<FFmpeg> {        const ffmpeg = new FFmpeg();        const coreURL = 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/esm/ffmpeg-core.js';        await ffmpeg.load({ coreURL });        return ffmpeg;    }    private scheduleCleanup(): void {        setTimeout(() => {            const idleTime = Date.now() - this.lastUsed;            if (idleTime >= this.IDLE_TIMEOUT && this.instance) {                console.log('[FFmpegManager] Liberando inst√¢ncia por inatividade');                this.instance = null;            } else {                this.scheduleCleanup();            }        }, this.IDLE_TIMEOUT);    }    forceUnload(): void {        this.instance = null;        this.lastUsed = 0;    }}const ffmpegManager = new FFmpegManager();```---üéØ SE√á√ÉO 5: C√ìDIGO COMPLETO OTIMIZADO```typescript/** * INSTRU√á√ÉO PARA LLM: * Este √© o c√≥digo final integrando todas as melhorias. * Use isto como refer√™ncia para implementa√ß√£o completa. */import { FFmpeg } from '@ffmpeg/ffmpeg';import type { ProgressCallback } from '@ffmpeg/ffmpeg/dist/esm/types';import { fetchFile } from '@ffmpeg/util';// ========== TIPOS E INTERFACES ==========interface ConversionOptions {    quality?: 'baixa' | 'm√©dia' | 'alta' | 'm√°xima';    onProgress?: (progress: number) => void;}interface ValidationResult {    isValid: boolean;    error?: string;}class ConversionError extends Error {    constructor(        message: string,        public readonly code: string,        public readonly userMessage: string    ) {        super(message);        this.name = 'ConversionError';    }}// ========== CONSTANTES ==========const VALID_VIDEO_TYPES = [    'video/mp4',    'video/webm',    'video/ogg',    'video/quicktime',    'video/x-msvideo',    'video/x-matroska'];const MAX_FILE_SIZE = 500 * 1024 * 1024; // 500MBconst QUALITY_PRESETS = {    baixa: ['-q:a', '9', '-ar', '22050'],    m√©dia: ['-q:a', '5', '-ar', '44100'],    alta: ['-q:a', '2', '-ar', '44100'],    m√°xima: ['-b:a', '320k', '-ar', '48000']};const ERROR_MESSAGES = {    INVALID_FILE: 'Arquivo inv√°lido',    FILE_TOO_LARGE: 'Arquivo muito grande',    UNSUPPORTED_FORMAT: 'Formato n√£o suportado',    CONVERSION_FAILED: 'Falha na convers√£o',    FFMPEG_LOAD_FAILED: 'Falha ao carregar motor de convers√£o'};// ========== GERENCIAMENTO DE FILA ==========class ConversionQueue {    private queue: Promise<void> = Promise.resolve();    enqueue<T>(task: () => Promise<T>): Promise<T> {        return new Promise((resolve, reject) => {            this.queue = this.queue                .then(() => task())                .then(resolve)                .catch(reject);        });    }}const conversionQueue = new ConversionQueue();// ========== GERENCIAMENTO FFMPEG ==========let ffmpegInstance: FFmpeg | null = null;let fileCounter = 0;const loadFFmpeg = async (): Promise<FFmpeg> => {    if (ffmpegInstance) {        return ffmpegInstance;    }    ffmpegInstance = new FFmpeg();    const coreURL = 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/esm/ffmpeg-core.js';    ffmpegInstance.on('log', ({ message }) => {        console.log('[FFmpeg]', message);    });    try {        await ffmpegInstance.load({ coreURL });    } catch (error) {        ffmpegInstance = null;        throw new ConversionError(            'FFmpeg core failed to load',            'FFMPEG_LOAD_FAILED',            'N√£o foi poss√≠vel carregar o motor de convers√£o. Verifique sua conex√£o e tente novamente.'        );    }    return ffmpegInstance;};// ========== UTILIDADES ==========const generateUniqueFilename = (extension: string): string => {    const timestamp = Date.now();    const random = Math.random().toString(36).substring(2, 9);    const counter = ++fileCounter;    return `${timestamp}_${random}_${counter}.${extension}`;};const validateVideoFile = (file: File): ValidationResult => {    if (!VALID_VIDEO_TYPES.includes(file.type)) {        return {            isValid: false,            error: `Formato n√£o suportado. Formatos aceitos: MP4, WebM, OGG, MOV, AVI, MKV`        };    }    if (file.size > MAX_FILE_SIZE) {        const maxSizeMB = Math.round(MAX_FILE_SIZE / (1024 * 1024));        return {            isValid: false,            error: `Arquivo muito grande. Tamanho m√°ximo: ${maxSizeMB}MB`        };    }    if (!file.name || file.name.length === 0) {        return {            isValid: false,            error: 'Nome de arquivo inv√°lido'        };    }    return { isValid: true };};const buildFFmpegArgs = (    inputFile: string,    outputFile: string,    quality: ConversionOptions['quality'] = 'alta'): string[] => {    const baseArgs = ['-i', inputFile, '-vn', '-acodec', 'libmp3lame'];    const qualityArgs = QUALITY_PRESETS[quality];    return [...baseArgs, ...qualityArgs, outputFile];};const safeCleanup = async (    ffmpeg: FFmpeg,    files: string[],    listener?: ProgressCallback): Promise<void> => {    if (listener) {        try {            ffmpeg.off('progress', listener);        } catch (error) {            console.warn('Falha ao remover listener:', error);        }    }    const deletePromises = files.map(async (filename) => {        try {            await ffmpeg.deleteFile(filename);        } catch (error) {            console.warn(`Falha ao deletar ${filename}:`, error);        }    });    await Promise.allSettled(deletePromises);};// ========== FUN√á√ÉO PRINCIPAL ==========const performConversion = async (    videoFile: File,    options: ConversionOptions = {}): Promise<File> => {    const { quality = 'alta', onProgress } = options;    const ffmpeg = await loadFFmpeg();    const inputFileName = generateUniqueFilename('video');    const outputFileName = generateUniqueFilename('mp3');    let progressListener: ProgressCallback | undefined;    if (onProgress) {        progressListener = ({ progress }) => {            const clampedProgress = Math.min(Math.max(progress, 0), 1);            onProgress(Math.round(clampedProgress * 100));        };        ffmpeg.on('progress', progressListener);    }    try {        // Escrever arquivo de entrada        try {            await ffmpeg.writeFile(inputFileName, await fetchFile(videoFile));        } catch (error) {            throw new ConversionError(                'Failed to write input file',                'FILE_WRITE_FAILED',                'Erro ao preparar o arquivo. O arquivo pode estar corrompido.'            );        }        // Executar convers√£o        try {            const args = buildFFmpegArgs(inputFileName, outputFileName, quality);            await ffmpeg.exec(args);        } catch (error) {            throw new ConversionError(                'FFmpeg exec failed',                'CONVERSION_FAILED',                'Falha durante a convers√£o. Verifique se o arquivo de v√≠deo √© v√°lido.'            );        }        // Ler arquivo de sa√≠da        let data: Uint8Array;        try {            data = await ffmpeg.readFile(outputFileName) as Uint8Array;        } catch (error) {            throw new ConversionError(                'Failed to read output file',                'FILE_READ_FAILED',                'Erro ao gerar o arquivo de √°udio. Tente novamente.'            );        }        // Criar File object        const audioBlob = new Blob([data], { type: 'audio/mpeg' });        const originalName = videoFile.name.split('.').slice(0, -1).join('.');        return new File([audioBlob], `${originalName}.mp3`, {            type: 'audio/mpeg',            lastModified: Date.now()        });    } finally {        await safeCleanup(ffmpeg, [inputFileName, outputFileName], progressListener);    }};// ========== API P√öBLICA ==========/** * Converte um arquivo de v√≠deo para MP3. *  * @param videoFile - Arquivo de v√≠deo a ser convertido * @param options - Op√ß√µes de convers√£o (qualidade, callback de progresso) * @returns Promise que resolve para o arquivo MP3 convertido * @throws ConversionError com mensagem em portugu√™s para o usu√°rio *  * @example * ```typescript * try { *   const audioFile = await convertToAudio(videoFile, { *     quality: 'alta', *     onProgress: (progress) => console.log(`${progress}%`) *   }); *   console.log('Convers√£o conclu√≠da:', audioFile.name); * } catch (error) { *   if (error instanceof ConversionError) { *     alert(error.userMessage); // Mensagem em portugu√™s *   } * } * ``` */export const convertToAudio = async (    videoFile: File,    options: ConversionOptions = {}): Promise<File> => {    // Valida√ß√£o de entrada    const validation = validateVideoFile(videoFile);    if (!validation.isValid) {        throw new ConversionError(            'Validation failed',            'VALIDATION_FAILED',            validation.error!        );    }    // Enfileira convers√£o para evitar race conditions    return conversionQueue.enqueue(() => performConversion(videoFile, options));};/** * For√ßa o descarregamento da inst√¢ncia FFmpeg da mem√≥ria. * √ötil para liberar recursos quando a convers√£o n√£o ser√° mais utilizada. */export const unloadFFmpeg = (): void => {    ffmpegInstance = null;    fileCounter = 0;};// Exporta tipos para uso pelo consumidorexport type { ConversionOptions, ConversionError };```---üéì SE√á√ÉO 6: DIRETRIZES PARA LLMQuando Usar Este C√≥digo```CEN√ÅRIO 1: Aplica√ß√£o web que precisa converter v√≠deos client-side‚Üí Use a implementa√ß√£o completa com fila de convers√£oCEN√ÅRIO 2: Aplica√ß√£o de p√°gina √∫nica com convers√µes espor√°dicas‚Üí Use implementa√ß√£o com nomes √∫nicos (mais simples)CEN√ÅRIO 3: Aplica√ß√£o que processa m√∫ltiplos arquivos simultaneamente‚Üí Obrigat√≥rio usar sistema de filas ou inst√¢ncias m√∫ltiplasCEN√ÅRIO 4: PWA ou aplica√ß√£o offline‚Üí Adicione service worker para cache do FFmpeg core```Padr√µes de Resposta ao Usu√°rio```typescript// CORRETO: Mensagens em portugu√™s, t√©cnicas em logstry {    await convertToAudio(file);} catch (error) {    console.error('[Technical]', error); // Ingl√™s para desenvolvedores    alert(error.userMessage); // Portugu√™s para usu√°rios}// INCORRETO: Misturar idiomasthrow new Error('Conversion failed para o arquivo');```Checklist de Implementa√ß√£o```‚ñ° Validar arquivo antes de processar‚ñ° Gerar nomes √∫nicos OU usar fila de convers√£o‚ñ° Implementar cleanup defensivo‚ñ° Fornecer feedback de progresso ao usu√°rio‚ñ° Tratar erros com mensagens em portugu√™s‚ñ° Testar com m√∫ltiplos arquivos simult√¢neos‚ñ° Testar com arquivos grandes (pr√≥ximos ao limite)‚ñ° Testar com formatos inv√°lidos‚ñ° Adicionar logs para debugging‚ñ° Documentar limita√ß√µes (tamanho m√°ximo, formatos)```Extens√µes RecomendadasSuporte a M√∫ltiplos Formatos de Sa√≠da```typescripttype OutputFormat = 'mp3' | 'aac' | 'ogg' | 'wav';```Cancelamento de Convers√£o```typescriptinterface CancellableConversion {    promise: Promise<File>;    cancel: () => void;}```Processamento em Lote```typescriptconst convertMultiple = async (    files: File[],    onBatchProgress?: (completed: number, total: number) => void): Promise<File[]>;```Persist√™ncia de Configura√ß√µes```typescriptconst saveUserPreferences = (options: ConversionOptions) => {    localStorage.setItem('conversionPrefs', JSON.stringify(options));};```---üìä SE√á√ÉO 7: MATRIZ DE DECIS√ÉO PARA LLM```PERGUNTA: "O usu√°rio quer converter v√≠deo para √°udio"‚îú‚îÄ Arquivo √∫nico?‚îÇ  ‚îú‚îÄ SIM ‚Üí Implementa√ß√£o b√°sica com valida√ß√£o‚îÇ  ‚îî‚îÄ N√ÉO ‚Üí Implementa√ß√£o com fila obrigat√≥ria‚îÇ‚îú‚îÄ M√∫ltiplos arquivos simult√¢neos poss√≠veis?‚îÇ  ‚îú‚îÄ SIM ‚Üí Sistema de filas obrigat√≥rio‚îÇ  ‚îî‚îÄ N√ÉO ‚Üí Pode usar nomes √∫nicos‚îÇ‚îú‚îÄ Aplica√ß√£o de longa dura√ß√£o?‚îÇ  ‚îú‚îÄ SIM ‚Üí Implementar gerenciamento de mem√≥ria‚îÇ  ‚îî‚îÄ N√ÉO ‚Üí Singleton simples suficiente‚îÇ‚îú‚îÄ Usu√°rio precisa cancelar convers√µes?‚îÇ  ‚îú‚îÄ SIM ‚Üí Implementar AbortController‚îÇ  ‚îî‚îÄ N√ÉO ‚Üí Implementa√ß√£o padr√£o‚îÇ‚îî‚îÄ Requer analytics/telemetria?   ‚îú‚îÄ SIM ‚Üí Adicionar sistema de m√©tricas   ‚îî‚îÄ N√ÉO ‚Üí Implementa√ß√£o sem monitoramento```---‚ö° SE√á√ÉO 8: OTIMIZA√á√ïES DE PERFORMANCE```typescript/** * INSTRU√á√ÉO PARA LLM: * Aplique estas otimiza√ß√µes apenas se necess√°rio. */// OTIMIZA√á√ÉO 1: Lazy loading do FFmpeg coreconst preloadFFmpeg = () => {    if ('requestIdleCallback' in window) {        requestIdleCallback(() => loadFFmpeg());    } else {        setTimeout(() => loadFFmpeg(), 1000);    }};// OTIMIZA√á√ÉO 2: Compress√£o adaptativa baseada em tamanhoconst getOptimalQuality = (fileSizeBytes: number): ConversionOptions['quality'] => {    const sizeMB = fileSizeBytes / (1024 * 1024);    if (sizeMB < 50) return 'm√°xima';    if (sizeMB < 150) return 'alta';    if (sizeMB < 300) return 'm√©dia';    return 'baixa';};// OTIMIZA√á√ÉO 3: Worker para n√£o bloquear UI// (Requer configura√ß√£o adicional do FFmpeg para Web Workers)```---üîí SE√á√ÉO 9: CONSIDERA√á√ïES DE SEGURAN√áA```typescript/** * INSTRU√á√ÉO PARA LLM: * Sempre inclua estas verifica√ß√µes de seguran√ßa. */// SEGURAN√áA 1: Sanitiza√ß√£o de nome de arquivoconst sanitizeFilename = (filename: string): string => {    return filename        .replace(/[^a-z0-9.\-_]/gi, '_') // Remove caracteres especiais        .replace(/\.{2,}/g, '.') // Remove m√∫ltiplos pontos        .slice(0, 255); // Limita tamanho};// SEGURAN√áA 2: Verifica√ß√£o de magic bytes (mais robusto que MIME)const verifyFileType = async (file: File): Promise<boolean> => {    const buffer = await file.slice(0, 12).arrayBuffer();    const bytes = new Uint8Array(buffer);    // MP4: 66 74 79 70 (ftyp)    // WebM: 1A 45 DF A3    // AVI: 52 49 46 46 (RIFF)    // ... adicione outros conforme necess√°rio    return true; // Implemente verifica√ß√£o real};// SEGURAN√áA 3: Rate limitingclass RateLimiter {    private attempts: number[] = [];    private readonly MAX_ATTEMPTS = 10;    private readonly TIME_WINDOW = 60000; // 1 minuto    canProceed(): boolean {        const now = Date.now();        this.attempts = this.attempts.filter(time => now - time < this.TIME_WINDOW);        if (this.attempts.length >= this.MAX_ATTEMPTS) {            return false;        }        this.attempts.push(now);        return true;    }}```---üìù TEMPLATE DE RESPOSTA PARA LLMQuando um desenvolvedor pedir ajuda com este c√≥digo, use esta estrutura:```1. DIAGN√ìSTICO   - Identifique o problema espec√≠fico   - Avalie severidade (cr√≠tica/alta/m√©dia/baixa)   - Verifique se requer mudan√ßa estrutural2. SOLU√á√ÉO   - Forne√ßa c√≥digo completo e funcional   - Use portugu√™s para mensagens de usu√°rio   - Inclua coment√°rios explicativos3. VALIDA√á√ÉO   - Liste cen√°rios de teste   - Forne√ßa exemplos de uso   - Aponte poss√≠veis edge cases4. PR√ìXIMOS PASSOS   - Sugira melhorias adicionais   - Indique documenta√ß√£o relevante   - Recomende ferramentas de teste```---‚úÖ CONCLUS√ÉOEste guia fornece uma an√°lise completa e solu√ß√µes pr√°ticas para todos os problemas identificados no c√≥digo original. A implementa√ß√£o final integra:‚úÖ Convers√µes thread-safe via fila‚úÖ Valida√ß√£o robusta de entrada‚úÖ Tratamento de erros contextual em portugu√™s‚úÖ Cleanup defensivo de recursos‚úÖ Sistema de qualidade configur√°vel‚úÖ Telemetria e monitoramento‚úÖ Seguran√ßa e sanitiza√ß√£o‚úÖ Documenta√ß√£o completaPara LLM: Priorize sempre a corre√ß√£o dos erros cr√≠ticos (#1 e #2) antes de adicionar features adicionais.